## equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다

1. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 객체의 hashCode 메서드는 몇 번을 호출해도 **일관되게 항상 같은 값** 을 반환해야 한다.(애플리케이션 재실행시에는 값이 달라져도 상관없다)
2. equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환(논리적 동치) : **Object의 기본 hashCode메서드는 물리적으로 다른 두 논리적 동치 객체를 다르다고 판단**하여, 서로 다른 값 반환.
3. equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다.


### hashCode 작성 요령
1. int result = c; 초기화. c는 객체의 첫 핵심 필드(equals 비교에 사용되는 필드)를 2.1 방식으로 계산한 해시코드
2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업 수행
   1. c를 계산
       a. 기본 타입 필드일 시 : Type.hashCode(f); 
       b. 참조 타입 필드 && 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교: 이 필드의 hashCode를 재귀적으로 호출.
       c. 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 
   2. 2.1에서 계산한 c로 **result = 31 * result + c**로 result 갱신
   3. result 반환

- Objects클래스의 정적 메서드 hash를 사용할수도 있지만, 입력 인수를 담기 위한 배열이 만들어지고, 기본 타입에 대해 박싱과 언박싱을 거치기 때문에 성능이 뛰어나진 않다.
- 클래스가 불변 && 해시코드 계산 비용이 크다 : 매번 새로 계산하지 않고, 캐싱하는 방식 사용
  - 타입의 객체가 주로 해시의 키로 사용될 것 같다면, 인스턴스가 만들어 질때 해시코드를 계산
- 해시코드의 키로 사용되지 않는 경우라면 hashCode가 처음 불릴 때 계산하는 lazy initialization 전략 활용.