객체들의 다 쓴 참조를 해제 하지 않으면 메모리 누수가 일어남
- 객체 참조 하나를 살려두면 GC는 그 객체 뿐 아니라, 그 객체가 참조하는 모든 객체(그 객체들이 참조하는 모든 객체....)를 회수하지 못한다.
- 따라서 단 몇개의 객체가 매우 많은 객체를 회수되지 못하게 한다.

- 누수를 막기 위해 해당 참조를 다 썼을 때 null처리(참조 해제)
- 모든 객체 참조를 쓰자마자 일일이 null처리할 필요 없음(null처리는 예외적인 경우)
- 자기 메모리를 직접 관리하는 클래스(예제의 elements배열)를 사용하는 개발자는 메모리 누수에 주의해야 함.

- 캐시 : 메모리 누수를 일으키는 주범2
  - 캐시 외부에서 Key를 참조하는 동안만 엔트리가 살아있는 캐시가 필요하다면 WeakHashMap 사용하여 캐시를 만들자
  - 시간이 지날수록 엔트리의 가치를 떨어뜨리는 방식 : 쓰지 않는 엔트리를 이따금 청소해주기 (Scheduled ThreadPoolExecutor)

- 리스너,콜백 : 메모리 누수의 주범3
  - 클라이언트가 콜백을 등록만 하고 명확히 해지 않는다면 콜백이 쌓여감
  - 이때 콜백을 약한 참조로 저장하면 가비지 컬렉터가 즉시 수거(역시 WeakHashMap)


- GC는 객체에 유효한 참조가 있으면 **reachable** , 없으면 **unreachable**로 구분. unreachable에 대해 GC수행.
- Weakly Reachable은 reachable은 맞지만 unreachable과 함께 가비지객체로 간주됨
1. 강한 참조
   일반적으로 new할당 후 새로운 객체를 만들어, 해당 객체를 참조
   - 할당된 객체를 해지하기 위해 null을 넣어도 위에서 만든 새로운 객체가 참조하고 있어 GC가 정리하지 않음

2. 약한 참조
   WeakReference를 이용하여 new 할당된 객체를 참조
   - 할당된 객체를 해지하기 위해 null을 넣으면 약한 참조중이기에 할당된 객체는 사라지고 WeakReference는 null값 가짐
   - stock클래스 참조